# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CLEC3wuLmWhwRUNDhS88kRT09xWiL10n
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os
# %matplotlib inline

def find_closest_centroids(X, centroids):

    # Set K
    K = centroids.shape[0]
    n=centroids.shape[1]
    # You need to return the following variables correctly
    idx = np.zeros(X.shape[0], dtype=int)

    ### START CODE HERE ###
    jh=0
    for ele in X:
        miny=10000
        ir=0
        j=0
        for centroid in centroids:
                temp=np.linalg.norm(ele-centroid)
                if temp<miny:
                    ir=j
                    miny=temp
                j+=1
        idx[jh]=ir
        jh+=1




     ### END CODE HERE ###

    return idx

def centroid_shifter(X,idx,K):
  m,n=X.shape
  print(n)
  centroids=np.zeros((K,n))
  l=np.zeros(K)
  # print("Aryan")
  # print(centroids.shape,X.shape)
  for i in range(m):
    nearest_centroid=idx[i]
    l[nearest_centroid]=l[nearest_centroid]+1
    centroids[nearest_centroid]=centroids[nearest_centroid]+X[i]
  for j in range(K):

      centroids[j]=centroids[j]/l[j]
  return centroids

def K_means_Algo(X,input_centroids,max_iters):
  centroids=input_centroids
  K=centroids.shape[0]
  n=centroids.shape[1]
  idx=np.zeros(X.shape[0],dtype=int)
  for i in range(max_iters):
    idx=find_closest_centroids(X,centroids)
    centroids=centroid_shifter(X,idx,K)
  return centroids,idx

def intializing_centroids(X,K):
  rdx=np.random.permutation(X.shape[0])
  centroids=X[rdx[:K]]
  return centroids
from PIL import Image
import numpy as np
import os

def compress_image(image_path, image_type, K=16, max_iters=10):
    # Read the image
    original_img = Image.open(image_path)
    
    # Convert image to RGB if not already
    original_img = original_img.convert('RGB')
    
    # Convert image to numpy array and normalize
    original_img_np = np.array(original_img, dtype=np.float32) / 255.0
    
    # Flatten the image to (m, n) where m is number of pixels and n is 3 (RGB)
    X_img = np.reshape(original_img_np, (original_img_np.shape[0] * original_img_np.shape[1], 3))
    
    # Initialize centroids and perform K-means clustering
    input_centroids = intializing_centroids(X_img, K)
    centroids, idx = K_means_Algo(X_img, input_centroids, max_iters)
    
    # Recover the image
    X_recovered = centroids[idx, :]
    X_recovered = np.reshape(X_recovered, original_img_np.shape)
    
    # Clip values to [0, 1], then scale to [0, 255] and convert to uint8
    X_recovered = np.clip(X_recovered, 0, 1)  # Ensure values are in [0, 1]
    X_recovered = (X_recovered * 255).astype(np.uint8)  # Scale to [0, 255] and convert to uint8
    
    # Create a PIL image from the numpy array
    compressed_image = Image.fromarray(X_recovered)
    
    # Save the image
    compressed_image_path = os.path.splitext(image_path)[0] + '_compressed.' + (image_type if image_type in ['jpg', 'png'] else 'jpg')
    compressed_image.save(compressed_image_path, format='JPEG' if image_type == 'jpg' else 'PNG')

    return compressed_image_path


# def compress_image(image_path,type, K=16, max_iters=10):
#     original_img = plt.imread(image_path)
#     if type=="jpg":
#       original_img_np = np.array(original_img, dtype=np.float32) / 255.0
#     X_img = np.reshape(original_img, (original_img.shape[0] * original_img.shape[1], 3))

#     input_centroids = intializing_centroids(X_img, K)
#     centroids, idx = K_means_Algo(X_img, input_centroids, max_iters)

#     idx = find_closest_centroids(X_img, centroids)
#     X_recovered = centroids[idx, :]

#     X_recovered = np.reshape(X_recovered, original_img.shape)
#     X_recovered = np.clip(X_recovered, 0, 1)
#     X_recovered = (X_recovered * 255).astype(np.uint8)

#     compressed_image = Image.fromarray(X_recovered)
#     compressed_image_path = os.path.splitext(image_path)[0] + '_compressed.jpg'
#     compressed_image.save(compressed_image_path)

#     return compressed_image_path
# original_img=plt.imread('myimage.jpg')
# print(original_img.shape)
# original_img=original_img/255
# plt.imshow(original_img)
# plt.axis('off')
# plt.show()
# X_img = np.reshape(original_img, (original_img.shape[0] * original_img.shape[1], 3))



# K=16
# max_iters=10
# input_centroids=intializing_centroids(X_img,K)
# print(input_centroids.shape)
# centroids,idx=K_means_Algo(X_img,input_centroids,max_iters)

# print("Shape of idx:", idx.shape)
# print("Closest centroid for the first five elements:", idx[:5])

# # Find the closest centroid of each pixel
# idx = find_closest_centroids(X_img, centroids)

# # Replace each pixel with the color of the closest centroid
# X_recovered = centroids[idx, :]

# # Reshape image into proper dimensions
# X_recovered = np.reshape(X_recovered, original_img.shape)
# print(X_recovered,X_recovered.shape)
# X_recovered = np.clip(X_recovered, 0, 1)  # Clip values to [0, 1]
# X_recovered = (X_recovered * 255).astype(np.uint8)  # Convert to [0, 255] and uint8

# # Display the compressed image using matplotlib
# plt.imshow(X_recovered)
# plt.axis('off')
# plt.title('Compressed Image with K-Means')
# plt.show()
# # img =Image.fromarray(X_recovered,'RGB')
# # X_recovered=X_recovered.astype(np.uint8)
# # img.show()
# # fig, ax = plt.subplots(1,2, figsize=(16,16))
# # plt.axis('off')

# # ax[0].imshow(original_img)
# # ax[0].set_title('Original')
# # ax[0].set_axis_off()


# # Display compressed image
# ax[1].imshow(X_recovered)
# ax[1].set_title('Compressed with %d colours'%K)
# ax[1].set_axis_off()